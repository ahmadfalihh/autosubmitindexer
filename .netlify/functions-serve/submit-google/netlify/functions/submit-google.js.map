{
  "version": 3,
  "sources": ["../../../../Documents/Bismillah2025SarengUmateKanjengNabiMuhammad/autosubmitindexerbysitemap/netlify/functions/submit-google.js"],
  "sourceRoot": "C:/Users/user/AppData/Local/Temp/tmp-15672-QjoxJGQeQDx8",
  "sourcesContent": ["// netlify/functions/submit-google.js\r\n// Using Standard Node.js Runtime for compatibility with crypto\r\nconst { webcrypto } = require('crypto');\r\n\r\n/**\r\n * Helper to import a private key string (PEM) for Web Crypto\r\n */\r\nasync function importPrivateKey(pem) {\r\n    // Remove header/footer and newlines\r\n    const pemHeader = \"-----BEGIN PRIVATE KEY-----\";\r\n    const pemFooter = \"-----END PRIVATE KEY-----\";\r\n    const pemContents = pem.trim()\r\n        .replace(pemHeader, \"\")\r\n        .replace(pemFooter, \"\")\r\n        .replace(/\\s/g, \"\");\r\n\r\n    // Base64 decode\r\n    const binaryDerString = atob(pemContents);\r\n    const binaryDer = new Uint8Array(binaryDerString.length);\r\n    for (let i = 0; i < binaryDerString.length; i++) {\r\n        binaryDer[i] = binaryDerString.charCodeAt(i);\r\n    }\r\n\r\n    // Use Node's webcrypto implementation\r\n    return webcrypto.subtle.importKey(\r\n        \"pkcs8\",\r\n        binaryDer.buffer,\r\n        {\r\n            name: \"RSASSA-PKCS1-v1_5\",\r\n            hash: \"SHA-256\",\r\n        },\r\n        false,\r\n        [\"sign\"]\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a signed JWT for Google Auth\r\n */\r\nasync function createJWT(serviceAccountEmail, privateKeyPem) {\r\n    const header = {\r\n        alg: \"RS256\",\r\n        typ: \"JWT\",\r\n    };\r\n\r\n    const now = Math.floor(Date.now() / 1000);\r\n    const claim = {\r\n        iss: serviceAccountEmail,\r\n        scope: \"https://www.googleapis.com/auth/indexing\",\r\n        aud: \"https://oauth2.googleapis.com/token\",\r\n        exp: now + 3600,\r\n        iat: now,\r\n    };\r\n\r\n    const encodedHeader = btoa(JSON.stringify(header));\r\n    const encodedClaim = btoa(JSON.stringify(claim));\r\n    const unsignedToken = `${encodedHeader}.${encodedClaim}`;\r\n\r\n    const privateKey = await importPrivateKey(privateKeyPem);\r\n    const signatureBuffer = await webcrypto.subtle.sign(\r\n        \"RSASSA-PKCS1-v1_5\",\r\n        privateKey,\r\n        new TextEncoder().encode(unsignedToken)\r\n    );\r\n\r\n    // Convert signature to base64url\r\n    const signature = btoa(String.fromCharCode(...new Uint8Array(signatureBuffer)))\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n        .replace(/=+$/, '');\r\n\r\n    return `${unsignedToken}.${signature}`;\r\n}\r\n\r\nasync function getAccessToken(serviceAccountEmail, privateKeyPem) {\r\n    const jwt = await createJWT(serviceAccountEmail, privateKeyPem);\r\n\r\n    const response = await fetch(\"https://oauth2.googleapis.com/token\", {\r\n        method: \"POST\",\r\n        headers: {\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n        },\r\n        body: new URLSearchParams({\r\n            grant_type: \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\r\n            assertion: jwt,\r\n        }),\r\n    });\r\n\r\n    const data = await response.json();\r\n    if (data.error) throw new Error(`Token Error: ${data.error_description || data.error}`);\r\n    return data.access_token;\r\n}\r\n\r\nexports.handler = async function (event, context) {\r\n    if (event.httpMethod !== \"POST\") {\r\n        return { statusCode: 405, body: \"Method Not Allowed\" };\r\n    }\r\n\r\n    try {\r\n        const { urls } = JSON.parse(event.body);\r\n\r\n        // 1. Get Service Account from Env\r\n        const serviceAccountStr = process.env.GOOGLE_SERVICE_ACCOUNT_JSON;\r\n\r\n        if (!serviceAccountStr) {\r\n            return {\r\n                statusCode: 500,\r\n                body: JSON.stringify({\r\n                    platform: \"google\",\r\n                    status: \"failed\",\r\n                    message: \"Missing GOOGLE_SERVICE_ACCOUNT_JSON env var.\"\r\n                })\r\n            };\r\n        }\r\n\r\n        let serviceAccount;\r\n        try {\r\n            serviceAccount = JSON.parse(serviceAccountStr);\r\n        } catch (e) {\r\n            return {\r\n                statusCode: 500,\r\n                body: JSON.stringify({ platform: \"google\", status: \"failed\", message: \"Invalid JSON in GOOGLE_SERVICE_ACCOUNT_JSON\" })\r\n            };\r\n        }\r\n\r\n        if (!urls || urls.length === 0) {\r\n            return { statusCode: 400, body: JSON.stringify({ error: \"No URLs\" }) };\r\n        }\r\n\r\n        // 2. Get Access Token\r\n        let accessToken;\r\n        try {\r\n            accessToken = await getAccessToken(serviceAccount.client_email, serviceAccount.private_key);\r\n        } catch (authErr) {\r\n            return {\r\n                statusCode: 500,\r\n                body: JSON.stringify({\r\n                    platform: \"google\",\r\n                    status: \"failed\",\r\n                    message: `Google Auth Failed: ${authErr.message}`\r\n                })\r\n            };\r\n        }\r\n\r\n        // 3. Submit to Indexing API\r\n        const results = [];\r\n        for (const url of urls) {\r\n            const response = await fetch(\"https://indexing.googleapis.com/v3/urlNotifications:publish\", {\r\n                method: \"POST\",\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                    \"Authorization\": `Bearer ${accessToken}`\r\n                },\r\n                body: JSON.stringify({\r\n                    url: url,\r\n                    type: \"URL_UPDATED\"\r\n                })\r\n            });\r\n\r\n            const resJson = await response.json();\r\n            results.push({\r\n                url,\r\n                status: response.ok ? \"success\" : \"failed\",\r\n                apiResponse: resJson\r\n            });\r\n        }\r\n\r\n        const hasFailure = results.some(r => r.status === 'failed');\r\n\r\n        return {\r\n            statusCode: 200,\r\n            body: JSON.stringify({\r\n                platform: \"google\",\r\n                status: hasFailure ? \"partial-failure\" : \"success\",\r\n                results\r\n            })\r\n        };\r\n\r\n    } catch (err) {\r\n        return { statusCode: 500, body: JSON.stringify({ platform: \"google\", status: \"error\", message: err.message }) };\r\n    }\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
